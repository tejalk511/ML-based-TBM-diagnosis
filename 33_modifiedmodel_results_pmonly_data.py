# -*- coding: utf-8 -*-
"""33.Modifiedmodel_results_pmonly_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BmpxitOiPkPzzLJXtWTMIn0l5XLf8nzN
"""

# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sklearn

# Import necessary modules
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from math import sqrt

# Keras specific
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.utils import to_categorical

#Importing libraries
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation
from sklearn.metrics import accuracy_score
from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier, VotingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

df = pd.read_csv('PM_dataset.csv')
print(df.shape)
#df.describe()

df.head()

target_column = ['Condition']
predictors = list(set(list(df.columns))-set(target_column))
# df[predictors] = df[predictors]/df[predictors].max()
df.describe()

X = df[predictors].values
y = df[target_column].values

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=40)
print(X_train.shape); print(X_test.shape)

# define the base models
gb_model = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1, max_depth=10)
rf_model = RandomForestClassifier(n_estimators=100, max_depth=10)
knn_model = KNeighborsClassifier(n_neighbors=5)
svm_model = SVC(C=1.0, kernel='linear')

# train the base models on the training set
gb_model.fit(X_train, y_train)

# train the base models on the training set
rf_model.fit(X_train, y_train)

# train the base models on the training set
knn_model.fit(X_train, y_train)

# train the base models on the training set
svm_model.fit(X_train, y_train)

# Making the final model using voting classifier
model = VotingClassifier( estimators=[('m1_1', gb_model), ('m1_2', rf_model), ('m2_1', knn_model), ('m2_2', svm_model)], voting='hard')

model.fit(X_train, y_train)

#make prediciton
y_train_pred = model.predict(X_train)
y_test_pred = model.predict(X_test)

from sklearn.metrics import precision_recall_fscore_support
#Training set performance
#score = model.score(X_test,y_test)

model_train_acc = accuracy_score(y_train, y_train_pred)
model_test_acc = accuracy_score(y_test, y_test_pred)

# Calculate accuracy scores
train_error = 1 - accuracy_score(y_train, y_train_pred)
test_error = 1 - accuracy_score(y_test, y_test_pred)

precision, recall, f1score, support = precision_recall_fscore_support(y_test, y_test_pred, average='weighted')

print("PERFORMANCE MEASURE - ")
print("")
print("Training Accuracy: ", model_train_acc)
print("Train error:", train_error)
print("")
print("Testing Accuracy: ", model_test_acc)
print("Test error:", test_error)
print("")
print("Precision:", precision)
print("Recall:", recall)
print("F1 score:", f1score)